// <auto-generated>
// This code was auto-generated by a tool, every time
// the tool executes this code will be reset.
//
// If you need to extend the classes generated to add
// fields or methods to them, please create partial
// declarations in another file.
// </auto-generated>
#pragma warning disable 0109
#pragma warning disable 1591


namespace Quantum {
  using Photon.Deterministic;
  using Quantum;
  using Quantum.Core;
  using Quantum.Collections;
  using Quantum.Inspector;
  using Quantum.Physics2D;
  using Quantum.Physics3D;
  using Byte = System.Byte;
  using SByte = System.SByte;
  using Int16 = System.Int16;
  using UInt16 = System.UInt16;
  using Int32 = System.Int32;
  using UInt32 = System.UInt32;
  using Int64 = System.Int64;
  using UInt64 = System.UInt64;
  using Boolean = System.Boolean;
  using String = System.String;
  using Object = System.Object;
  using FlagsAttribute = System.FlagsAttribute;
  using SerializableAttribute = System.SerializableAttribute;
  using MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;
  using MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;
  using FieldOffsetAttribute = System.Runtime.InteropServices.FieldOffsetAttribute;
  using StructLayoutAttribute = System.Runtime.InteropServices.StructLayoutAttribute;
  using LayoutKind = System.Runtime.InteropServices.LayoutKind;
  #if QUANTUM_UNITY //;
  using TooltipAttribute = UnityEngine.TooltipAttribute;
  using HeaderAttribute = UnityEngine.HeaderAttribute;
  using SpaceAttribute = UnityEngine.SpaceAttribute;
  using RangeAttribute = UnityEngine.RangeAttribute;
  using HideInInspectorAttribute = UnityEngine.HideInInspector;
  using PreserveAttribute = UnityEngine.Scripting.PreserveAttribute;
  using FormerlySerializedAsAttribute = UnityEngine.Serialization.FormerlySerializedAsAttribute;
  using MovedFromAttribute = UnityEngine.Scripting.APIUpdating.MovedFromAttribute;
  using CreateAssetMenu = UnityEngine.CreateAssetMenuAttribute;
  using RuntimeInitializeOnLoadMethodAttribute = UnityEngine.RuntimeInitializeOnLoadMethodAttribute;
  #endif //;
  
  public enum ActionAvailabilityCondition : int {
    Always,
    InJumping,
    NotInJumping,
  }
  public enum ActionType : int {
    Jump,
    Dash,
    Attack_Gun,
  }
  public enum CinematicCameraType : int {
    StartCamera,
    WinCamera,
    LoseCamera,
  }
  public enum EntityType : int {
    None,
    Enemy,
    DynamicEntity,
    StaticEntity,
  }
  public enum GameState : int {
    None,
    Initializing,
    Starting,
    Running,
    GoalScored,
    GameOver,
  }
  public enum PlayerLocomotionType : int {
    Idle,
    Move,
    Brake,
    Dash,
    Stun,
    Break,
  }
  public enum PlayerPartsType : int {
    Body,
    Gun,
  }
  public enum PlayerPostureType : int {
    Standing,
    Jumping,
    Falling,
  }
  public enum PlayerTeam : int {
    A,
    B,
  }
  public enum PlayerWeaponStateType : int {
    None,
    GunAttack,
  }
  [System.FlagsAttribute()]
  public enum InputButtons : int {
    Jump = 1 << 0,
    Dash = 1 << 1,
    Gun = 1 << 2,
    SwitchTarget = 1 << 3,
  }
  public static unsafe partial class FlagsExtensions {
    public static Boolean IsFlagSet(this InputButtons self, InputButtons flag) {
      return (self & flag) == flag;
    }
    public static InputButtons SetFlag(this InputButtons self, InputButtons flag) {
      return self | flag;
    }
    public static InputButtons ClearFlag(this InputButtons self, InputButtons flag) {
      return self & ~flag;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet128 {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[2];
    public const Int32 BitsSize = 128;
    public Int32 Length {
      get {
        return 128;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet128*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 128, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet128 FromArray(UInt64[] values) {
      Assert.Always(2 == values.Length, "Invalid array size", values.Length);
      BitSet128 result = default;
      for (int i = 0; i < 2; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 128);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 128);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 16);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 4463;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 2);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet128*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 2);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet2048 {
    public const Int32 SIZE = 256;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[32];
    public const Int32 BitsSize = 2048;
    public Int32 Length {
      get {
        return 2048;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet2048*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 2048, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet2048 FromArray(UInt64[] values) {
      Assert.Always(32 == values.Length, "Invalid array size", values.Length);
      BitSet2048 result = default;
      for (int i = 0; i < 32; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2048);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2048);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 256);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 3319;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 32);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet2048*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 32);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet256 {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[4];
    public const Int32 BitsSize = 256;
    public Int32 Length {
      get {
        return 256;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet256*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 256, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet256 FromArray(UInt64[] values) {
      Assert.Always(4 == values.Length, "Invalid array size", values.Length);
      BitSet256 result = default;
      for (int i = 0; i < 4; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 256);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 256);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 32);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 14057;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 4);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet256*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 4);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet4096 {
    public const Int32 SIZE = 512;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[64];
    public const Int32 BitsSize = 4096;
    public Int32 Length {
      get {
        return 4096;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet4096*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 4096, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet4096 FromArray(UInt64[] values) {
      Assert.Always(64 == values.Length, "Invalid array size", values.Length);
      BitSet4096 result = default;
      for (int i = 0; i < 64; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 4096);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 4096);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 512);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 1433;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 64);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet4096*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 64);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet512 {
    public const Int32 SIZE = 64;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[8];
    public const Int32 BitsSize = 512;
    public Int32 Length {
      get {
        return 512;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet512*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 512, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet512 FromArray(UInt64[] values) {
      Assert.Always(8 == values.Length, "Invalid array size", values.Length);
      BitSet512 result = default;
      for (int i = 0; i < 8; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 512);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 512);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 64);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 17491;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 8);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet512*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 8);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet6 {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[1];
    public const Int32 BitsSize = 6;
    public Int32 Length {
      get {
        return 6;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet6*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 6, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet6 FromArray(UInt64[] values) {
      Assert.Always(1 == values.Length, "Invalid array size", values.Length);
      BitSet6 result = default;
      for (int i = 0; i < 1; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 6);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 6);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 8);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 13669;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 1);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet6*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 1);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct ActionsParameter {
    public const Int32 SIZE = 112;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public JumpAction jumpAction;
    [FieldOffset(16)]
    public DashAction dashAction;
    [FieldOffset(48)]
    public GunAction gunAction;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 8093;
        hash = hash * 31 + jumpAction.GetHashCode();
        hash = hash * 31 + dashAction.GetHashCode();
        hash = hash * 31 + gunAction.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (ActionsParameter*)ptr;
        Quantum.JumpAction.Serialize(&p->jumpAction, serializer);
        Quantum.DashAction.Serialize(&p->dashAction, serializer);
        Quantum.GunAction.Serialize(&p->gunAction, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct ActiveActionInfo {
    public const Int32 SIZE = 88;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public Int32 activeActionIndex;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public FPVector3 castDirection;
    [FieldOffset(56)]
    [ExcludeFromPrototype()]
    public FPQuaternion castRotation;
    [FieldOffset(32)]
    [ExcludeFromPrototype()]
    public FPVector3 castVelocity;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 15739;
        hash = hash * 31 + activeActionIndex.GetHashCode();
        hash = hash * 31 + castDirection.GetHashCode();
        hash = hash * 31 + castRotation.GetHashCode();
        hash = hash * 31 + castVelocity.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (ActiveActionInfo*)ptr;
        serializer.Stream.Serialize(&p->activeActionIndex);
        FPVector3.Serialize(&p->castDirection, serializer);
        FPVector3.Serialize(&p->castVelocity, serializer);
        FPQuaternion.Serialize(&p->castRotation, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BodyDatabase {
    public const Int32 SIZE = 144;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(16)]
    public AssetRef<CharacterController3DConfig> defaultConfig;
    [FieldOffset(8)]
    public AssetRef<CharacterController3DConfig> dashConfig;
    [FieldOffset(88)]
    public FP healthPoint;
    [FieldOffset(128)]
    public FP toughPoint;
    [FieldOffset(120)]
    public FP minMoveSpeed;
    [FieldOffset(112)]
    public FP maxMoveSpeed;
    [FieldOffset(80)]
    public FP groundTurnSpeed;
    [FieldOffset(40)]
    public FP brakeMultiplier;
    [FieldOffset(24)]
    public FP accelerationDuration;
    [FieldOffset(104)]
    public FP maxJumpHeight;
    [FieldOffset(72)]
    public FP gravity;
    [FieldOffset(64)]
    public FP fallSpeedMultiplier;
    [FieldOffset(32)]
    public FP airTurnSpeed;
    [FieldOffset(96)]
    public FP jumpLandStunDuration;
    [FieldOffset(0)]
    public QBoolean keepInertialVelocity;
    [FieldOffset(56)]
    public FP dashMoveSpeed;
    [FieldOffset(136)]
    public FP toughPointRecoverAmount;
    [FieldOffset(48)]
    public FP breakDuration;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 14389;
        hash = hash * 31 + defaultConfig.GetHashCode();
        hash = hash * 31 + dashConfig.GetHashCode();
        hash = hash * 31 + healthPoint.GetHashCode();
        hash = hash * 31 + toughPoint.GetHashCode();
        hash = hash * 31 + minMoveSpeed.GetHashCode();
        hash = hash * 31 + maxMoveSpeed.GetHashCode();
        hash = hash * 31 + groundTurnSpeed.GetHashCode();
        hash = hash * 31 + brakeMultiplier.GetHashCode();
        hash = hash * 31 + accelerationDuration.GetHashCode();
        hash = hash * 31 + maxJumpHeight.GetHashCode();
        hash = hash * 31 + gravity.GetHashCode();
        hash = hash * 31 + fallSpeedMultiplier.GetHashCode();
        hash = hash * 31 + airTurnSpeed.GetHashCode();
        hash = hash * 31 + jumpLandStunDuration.GetHashCode();
        hash = hash * 31 + keepInertialVelocity.GetHashCode();
        hash = hash * 31 + dashMoveSpeed.GetHashCode();
        hash = hash * 31 + toughPointRecoverAmount.GetHashCode();
        hash = hash * 31 + breakDuration.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BodyDatabase*)ptr;
        QBoolean.Serialize(&p->keepInertialVelocity, serializer);
        AssetRef.Serialize(&p->dashConfig, serializer);
        AssetRef.Serialize(&p->defaultConfig, serializer);
        FP.Serialize(&p->accelerationDuration, serializer);
        FP.Serialize(&p->airTurnSpeed, serializer);
        FP.Serialize(&p->brakeMultiplier, serializer);
        FP.Serialize(&p->breakDuration, serializer);
        FP.Serialize(&p->dashMoveSpeed, serializer);
        FP.Serialize(&p->fallSpeedMultiplier, serializer);
        FP.Serialize(&p->gravity, serializer);
        FP.Serialize(&p->groundTurnSpeed, serializer);
        FP.Serialize(&p->healthPoint, serializer);
        FP.Serialize(&p->jumpLandStunDuration, serializer);
        FP.Serialize(&p->maxJumpHeight, serializer);
        FP.Serialize(&p->maxMoveSpeed, serializer);
        FP.Serialize(&p->minMoveSpeed, serializer);
        FP.Serialize(&p->toughPoint, serializer);
        FP.Serialize(&p->toughPointRecoverAmount, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BreakStatusEffect {
    public const Int32 SIZE = 48;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(24)]
    public FP projectileIndex;
    [FieldOffset(8)]
    public FP downMovenmentDistanceXZ;
    [FieldOffset(16)]
    public FP downMovenmentDistanceY;
    [FieldOffset(0)]
    public QBoolean isHitWall;
    [FieldOffset(32)]
    [ExcludeFromPrototype()]
    public CountdownTimer durationTimer;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 9337;
        hash = hash * 31 + projectileIndex.GetHashCode();
        hash = hash * 31 + downMovenmentDistanceXZ.GetHashCode();
        hash = hash * 31 + downMovenmentDistanceY.GetHashCode();
        hash = hash * 31 + isHitWall.GetHashCode();
        hash = hash * 31 + durationTimer.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BreakStatusEffect*)ptr;
        QBoolean.Serialize(&p->isHitWall, serializer);
        FP.Serialize(&p->downMovenmentDistanceXZ, serializer);
        FP.Serialize(&p->downMovenmentDistanceY, serializer);
        FP.Serialize(&p->projectileIndex, serializer);
        Quantum.CountdownTimer.Serialize(&p->durationTimer, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct CountdownTimer {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public FP TimeLeft;
    [FieldOffset(0)]
    public FP StartTime;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 8641;
        hash = hash * 31 + TimeLeft.GetHashCode();
        hash = hash * 31 + StartTime.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (CountdownTimer*)ptr;
        FP.Serialize(&p->StartTime, serializer);
        FP.Serialize(&p->TimeLeft, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct DashAction {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(4)]
    public QBoolean isDashing;
    [FieldOffset(0)]
    public QBoolean dashStartInAir;
    [FieldOffset(8)]
    public FPVector3 airDashInertiaDirection;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 15877;
        hash = hash * 31 + isDashing.GetHashCode();
        hash = hash * 31 + dashStartInAir.GetHashCode();
        hash = hash * 31 + airDashInertiaDirection.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (DashAction*)ptr;
        QBoolean.Serialize(&p->dashStartInAir, serializer);
        QBoolean.Serialize(&p->isDashing, serializer);
        FPVector3.Serialize(&p->airDashInertiaDirection, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct GunAction {
    public const Int32 SIZE = 64;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(40)]
    public FPVector3 projectileSpawnPosition;
    [FieldOffset(16)]
    public FPVector3 projectileDirection;
    [FieldOffset(0)]
    public CountdownTimer consecutiveShootIntervalTimer;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 5689;
        hash = hash * 31 + projectileSpawnPosition.GetHashCode();
        hash = hash * 31 + projectileDirection.GetHashCode();
        hash = hash * 31 + consecutiveShootIntervalTimer.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (GunAction*)ptr;
        Quantum.CountdownTimer.Serialize(&p->consecutiveShootIntervalTimer, serializer);
        FPVector3.Serialize(&p->projectileDirection, serializer);
        FPVector3.Serialize(&p->projectileSpawnPosition, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [Serializable()]
  public unsafe partial struct GunDatabase {
    public const Int32 SIZE = 80;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetRef<EntityPrototype> projectilePrototype;
    [FieldOffset(56)]
    public FPVector3 gunMuzzleOffset;
    [FieldOffset(8)]
    public FP gunConsecutiveShootIntervalDuration;
    [FieldOffset(16)]
    public FP projectileAttackPoint;
    [FieldOffset(24)]
    public FP projectileDownPoint;
    [FieldOffset(40)]
    public FP projectileKnockBackPoint;
    [FieldOffset(48)]
    public FP projectileSpeed;
    [FieldOffset(32)]
    public FP projectileDuration;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 7517;
        hash = hash * 31 + projectilePrototype.GetHashCode();
        hash = hash * 31 + gunMuzzleOffset.GetHashCode();
        hash = hash * 31 + gunConsecutiveShootIntervalDuration.GetHashCode();
        hash = hash * 31 + projectileAttackPoint.GetHashCode();
        hash = hash * 31 + projectileDownPoint.GetHashCode();
        hash = hash * 31 + projectileKnockBackPoint.GetHashCode();
        hash = hash * 31 + projectileSpeed.GetHashCode();
        hash = hash * 31 + projectileDuration.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (GunDatabase*)ptr;
        AssetRef.Serialize(&p->projectilePrototype, serializer);
        FP.Serialize(&p->gunConsecutiveShootIntervalDuration, serializer);
        FP.Serialize(&p->projectileAttackPoint, serializer);
        FP.Serialize(&p->projectileDownPoint, serializer);
        FP.Serialize(&p->projectileDuration, serializer);
        FP.Serialize(&p->projectileKnockBackPoint, serializer);
        FP.Serialize(&p->projectileSpeed, serializer);
        FPVector3.Serialize(&p->gunMuzzleOffset, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Input {
    public const Int32 SIZE = 104;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(28)]
    public Button Jump;
    [FieldOffset(4)]
    public Button Dash;
    [FieldOffset(16)]
    public Button Gun;
    [FieldOffset(40)]
    public Button SwitchTarget;
    [FieldOffset(80)]
    public FPVector3 PlayerMovementDirection;
    [FieldOffset(56)]
    public FPVector3 CameraMovementDirection;
    [FieldOffset(0)]
    public Byte MovementEncoded;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 19249;
        hash = hash * 31 + Jump.GetHashCode();
        hash = hash * 31 + Dash.GetHashCode();
        hash = hash * 31 + Gun.GetHashCode();
        hash = hash * 31 + SwitchTarget.GetHashCode();
        hash = hash * 31 + PlayerMovementDirection.GetHashCode();
        hash = hash * 31 + CameraMovementDirection.GetHashCode();
        hash = hash * 31 + MovementEncoded.GetHashCode();
        return hash;
      }
    }
    static partial void GetMaxCountCodeGen(ref int maxCount) {
      maxCount = 6;
    }
    public Boolean IsDown(InputButtons button) {
      switch (button) {
        case InputButtons.Jump: return Jump.IsDown;
        case InputButtons.Dash: return Dash.IsDown;
        case InputButtons.Gun: return Gun.IsDown;
        case InputButtons.SwitchTarget: return SwitchTarget.IsDown;
        default: return false;
      }
    }
    public Boolean WasPressed(InputButtons button) {
      switch (button) {
        case InputButtons.Jump: return Jump.WasPressed;
        case InputButtons.Dash: return Dash.WasPressed;
        case InputButtons.Gun: return Gun.WasPressed;
        case InputButtons.SwitchTarget: return SwitchTarget.WasPressed;
        default: return false;
      }
    }
    static partial void SerializeCodeGen(void* ptr, FrameSerializer serializer) {
        var p = (Input*)ptr;
        serializer.Stream.Serialize(&p->MovementEncoded);
        Button.Serialize(&p->Dash, serializer);
        Button.Serialize(&p->Gun, serializer);
        Button.Serialize(&p->Jump, serializer);
        Button.Serialize(&p->SwitchTarget, serializer);
        FPVector3.Serialize(&p->CameraMovementDirection, serializer);
        FPVector3.Serialize(&p->PlayerMovementDirection, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct JumpAction {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public QBoolean isJumping;
    [FieldOffset(8)]
    public FP currentVerticalVelocity;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 20899;
        hash = hash * 31 + isJumping.GetHashCode();
        hash = hash * 31 + currentVerticalVelocity.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (JumpAction*)ptr;
        QBoolean.Serialize(&p->isJumping, serializer);
        FP.Serialize(&p->currentVerticalVelocity, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PlayerActionInfo {
    public const Int32 SIZE = 72;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public ActionType actionType;
    [FieldOffset(16)]
    public AssetRef<PlayerActionData> actionData;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public QBoolean isActionActiveStart;
    [FieldOffset(4)]
    [ExcludeFromPrototype()]
    public QBoolean isActionActiveEnd;
    [FieldOffset(56)]
    [ExcludeFromPrototype()]
    public CountdownTimer inputBufferTimer;
    [FieldOffset(24)]
    [ExcludeFromPrototype()]
    public CountdownTimer activateTimer;
    [FieldOffset(40)]
    [ExcludeFromPrototype()]
    public CountdownTimer cooldownTimer;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 1153;
        hash = hash * 31 + (Int32)actionType;
        hash = hash * 31 + actionData.GetHashCode();
        hash = hash * 31 + isActionActiveStart.GetHashCode();
        hash = hash * 31 + isActionActiveEnd.GetHashCode();
        hash = hash * 31 + inputBufferTimer.GetHashCode();
        hash = hash * 31 + activateTimer.GetHashCode();
        hash = hash * 31 + cooldownTimer.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PlayerActionInfo*)ptr;
        serializer.Stream.Serialize((Int32*)&p->actionType);
        QBoolean.Serialize(&p->isActionActiveEnd, serializer);
        QBoolean.Serialize(&p->isActionActiveStart, serializer);
        AssetRef.Serialize(&p->actionData, serializer);
        Quantum.CountdownTimer.Serialize(&p->activateTimer, serializer);
        Quantum.CountdownTimer.Serialize(&p->cooldownTimer, serializer);
        Quantum.CountdownTimer.Serialize(&p->inputBufferTimer, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct StunStatusEffect {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public CountdownTimer durationTimer;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 20719;
        hash = hash * 31 + durationTimer.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (StunStatusEffect*)ptr;
        Quantum.CountdownTimer.Serialize(&p->durationTimer, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct _globals_ {
    public const Int32 SIZE = 1248;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public AssetRef<Map> Map;
    [FieldOffset(8)]
    public FP DeltaTime;
    [FieldOffset(16)]
    public NavMeshRegionMask NavMeshRegions;
    [FieldOffset(32)]
    public PhysicsEngineState PhysicsState2D;
    [FieldOffset(48)]
    public PhysicsEngineState PhysicsState3D;
    [FieldOffset(64)]
    public RNGSession RngSession;
    [FieldOffset(80)]
    public FrameMetaData FrameMetaData;
    [FieldOffset(128)]
    public BitSet1024 Systems;
    [FieldOffset(256)]
    public PhysicsSceneSettings PhysicsSettings;
    [FieldOffset(552)]
    public Int32 PlayerConnectedCount;
    [FieldOffset(560)]
    [FramePrinter.FixedArrayAttribute(typeof(Input), 6)]
    private fixed Byte _input_[624];
    [FieldOffset(1184)]
    public BitSet6 PlayerLastConnectionState;
    [FieldOffset(1192)]
    public GameState gameState;
    [FieldOffset(1216)]
    public CountdownTimer gameStateTimer;
    [FieldOffset(1232)]
    public CountdownTimer mainGameTimer;
    [FieldOffset(1200)]
    [FramePrinter.FixedArrayAttribute(typeof(FP), 2)]
    private fixed Byte _teamPlayerCount_[16];
    public FixedArray<Input> input {
      get {
        fixed (byte* p = _input_) { return new FixedArray<Input>(p, 104, 6); }
      }
    }
    public FixedArray<FP> teamPlayerCount {
      get {
        fixed (byte* p = _teamPlayerCount_) { return new FixedArray<FP>(p, 8, 2); }
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 12473;
        hash = hash * 31 + Map.GetHashCode();
        hash = hash * 31 + DeltaTime.GetHashCode();
        hash = hash * 31 + NavMeshRegions.GetHashCode();
        hash = hash * 31 + PhysicsState2D.GetHashCode();
        hash = hash * 31 + PhysicsState3D.GetHashCode();
        hash = hash * 31 + RngSession.GetHashCode();
        hash = hash * 31 + FrameMetaData.GetHashCode();
        hash = hash * 31 + Systems.GetHashCode();
        hash = hash * 31 + PhysicsSettings.GetHashCode();
        hash = hash * 31 + PlayerConnectedCount.GetHashCode();
        hash = hash * 31 + HashCodeUtils.GetArrayHashCode(input);
        hash = hash * 31 + PlayerLastConnectionState.GetHashCode();
        hash = hash * 31 + (Int32)gameState;
        hash = hash * 31 + gameStateTimer.GetHashCode();
        hash = hash * 31 + mainGameTimer.GetHashCode();
        hash = hash * 31 + HashCodeUtils.GetArrayHashCode(teamPlayerCount);
        return hash;
      }
    }
    static partial void SerializeCodeGen(void* ptr, FrameSerializer serializer) {
        var p = (_globals_*)ptr;
        AssetRef.Serialize(&p->Map, serializer);
        FP.Serialize(&p->DeltaTime, serializer);
        NavMeshRegionMask.Serialize(&p->NavMeshRegions, serializer);
        PhysicsEngineState.Serialize(&p->PhysicsState2D, serializer);
        PhysicsEngineState.Serialize(&p->PhysicsState3D, serializer);
        RNGSession.Serialize(&p->RngSession, serializer);
        FrameMetaData.Serialize(&p->FrameMetaData, serializer);
        Quantum.BitSet1024.Serialize(&p->Systems, serializer);
        PhysicsSceneSettings.Serialize(&p->PhysicsSettings, serializer);
        serializer.Stream.Serialize(&p->PlayerConnectedCount);
        FixedArray.Serialize(p->input, serializer, Statics.SerializeInput);
        Quantum.BitSet6.Serialize(&p->PlayerLastConnectionState, serializer);
        serializer.Stream.Serialize((Int32*)&p->gameState);
        FixedArray.Serialize(p->teamPlayerCount, serializer, Statics.SerializeFP);
        Quantum.CountdownTimer.Serialize(&p->gameStateTimer, serializer);
        Quantum.CountdownTimer.Serialize(&p->mainGameTimer, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct EnemyFlagComponent : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    private fixed Byte _alignment_padding_[4];
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 12853;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (EnemyFlagComponent*)ptr;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PlayerActionComponent : Quantum.IComponent {
    public const Int32 SIZE = 416;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(216)]
    public ActiveActionInfo activeActionInfo;
    [FieldOffset(0)]
    [Header("Action Order: Jump, Dash, Gun")]
    [FramePrinter.FixedArrayAttribute(typeof(PlayerActionInfo), 3)]
    private fixed Byte _actionInfoArray_[216];
    [FieldOffset(304)]
    public ActionsParameter actionsParameter;
    public FixedArray<PlayerActionInfo> actionInfoArray {
      get {
        fixed (byte* p = _actionInfoArray_) { return new FixedArray<PlayerActionInfo>(p, 72, 3); }
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 5749;
        hash = hash * 31 + activeActionInfo.GetHashCode();
        hash = hash * 31 + HashCodeUtils.GetArrayHashCode(actionInfoArray);
        hash = hash * 31 + actionsParameter.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PlayerActionComponent*)ptr;
        FixedArray.Serialize(p->actionInfoArray, serializer, Statics.SerializePlayerActionInfo);
        Quantum.ActiveActionInfo.Serialize(&p->activeActionInfo, serializer);
        Quantum.ActionsParameter.Serialize(&p->actionsParameter, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PlayerDatabaseComponent : Quantum.IComponent {
    public const Int32 SIZE = 232;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    [Header("Parts Indexes")]
    public QListPtr<FP> equippingPartsIndexesList;
    [FieldOffset(88)]
    [Header("Status Database")]
    public BodyDatabase bodyDatabase;
    [FieldOffset(8)]
    public GunDatabase gunDatabase;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 3779;
        hash = hash * 31 + equippingPartsIndexesList.GetHashCode();
        hash = hash * 31 + bodyDatabase.GetHashCode();
        hash = hash * 31 + gunDatabase.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      equippingPartsIndexesList = default;
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.PlayerDatabaseComponent*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PlayerDatabaseComponent*)ptr;
        QList.Serialize(&p->equippingPartsIndexesList, serializer, Statics.SerializeFP);
        Quantum.GunDatabase.Serialize(&p->gunDatabase, serializer);
        Quantum.BodyDatabase.Serialize(&p->bodyDatabase, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PlayerMovementComponent : Quantum.IComponent {
    public const Int32 SIZE = 152;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    [Header("average Horizontal Velocity")]
    public FP currentCacheIndex;
    [FieldOffset(80)]
    [FramePrinter.FixedArrayAttribute(typeof(FPVector3), 3)]
    private fixed Byte _velocityCache_[72];
    [FieldOffset(32)]
    public FPVector3 averageHorizontalVelocity;
    [FieldOffset(0)]
    [Header("current Horizontal Velocity")]
    public QBoolean isAccelerating;
    [FieldOffset(16)]
    public CountdownTimer accelerationTimer;
    [FieldOffset(56)]
    public FPVector3 currentHorizontalVelocity;
    public FixedArray<FPVector3> velocityCache {
      get {
        fixed (byte* p = _velocityCache_) { return new FixedArray<FPVector3>(p, 24, 3); }
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 2447;
        hash = hash * 31 + currentCacheIndex.GetHashCode();
        hash = hash * 31 + HashCodeUtils.GetArrayHashCode(velocityCache);
        hash = hash * 31 + averageHorizontalVelocity.GetHashCode();
        hash = hash * 31 + isAccelerating.GetHashCode();
        hash = hash * 31 + accelerationTimer.GetHashCode();
        hash = hash * 31 + currentHorizontalVelocity.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PlayerMovementComponent*)ptr;
        QBoolean.Serialize(&p->isAccelerating, serializer);
        FP.Serialize(&p->currentCacheIndex, serializer);
        Quantum.CountdownTimer.Serialize(&p->accelerationTimer, serializer);
        FPVector3.Serialize(&p->averageHorizontalVelocity, serializer);
        FPVector3.Serialize(&p->currentHorizontalVelocity, serializer);
        FixedArray.Serialize(p->velocityCache, serializer, Statics.SerializeFPVector3);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PlayerSpawnerComponent : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public PlayerTeam PlayerTeam;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 13421;
        hash = hash * 31 + (Int32)PlayerTeam;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PlayerSpawnerComponent*)ptr;
        serializer.Stream.Serialize((Int32*)&p->PlayerTeam);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PlayerStatusComponent : Quantum.IComponent {
    public const Int32 SIZE = 176;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(16)]
    [ExcludeFromPrototype()]
    public PlayerRef playerRef;
    [FieldOffset(24)]
    [ExcludeFromPrototype()]
    public EntityRef SpawnerEntityRef;
    [FieldOffset(20)]
    public PlayerTeam PlayerTeam;
    [FieldOffset(80)]
    [ExcludeFromPrototype()]
    public CountdownTimer jumpCoyoteTimer;
    [FieldOffset(96)]
    [ExcludeFromPrototype()]
    public CountdownTimer unbeatableTimer;
    [FieldOffset(64)]
    [ExcludeFromPrototype()]
    public CountdownTimer damageBufferTimer;
    [FieldOffset(4)]
    [ExcludeFromPrototype()]
    public PlayerLocomotionType playerLocomotionType;
    [FieldOffset(12)]
    [ExcludeFromPrototype()]
    public PlayerPostureType playerPostureType;
    [FieldOffset(0)]
    [ExcludeFromPrototype()]
    public PlayerLocomotionType lastLocomotionType;
    [FieldOffset(8)]
    [ExcludeFromPrototype()]
    public PlayerPostureType lastPostureType;
    [FieldOffset(56)]
    [ExcludeFromPrototype()]
    public FP lastVerticalSpeed;
    [FieldOffset(32)]
    [Header("Enemy Entity")]
    public EntityRef enemyEntityRef;
    [FieldOffset(40)]
    [Header("Player Status")]
    public FP currentHealthPoint;
    [FieldOffset(48)]
    public FP currentToughPoint;
    [FieldOffset(112)]
    [Header("Player Status Effect")]
    public StunStatusEffect stunStatusEffect;
    [FieldOffset(128)]
    public BreakStatusEffect breakStatusEffect;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 19709;
        hash = hash * 31 + playerRef.GetHashCode();
        hash = hash * 31 + SpawnerEntityRef.GetHashCode();
        hash = hash * 31 + (Int32)PlayerTeam;
        hash = hash * 31 + jumpCoyoteTimer.GetHashCode();
        hash = hash * 31 + unbeatableTimer.GetHashCode();
        hash = hash * 31 + damageBufferTimer.GetHashCode();
        hash = hash * 31 + (Int32)playerLocomotionType;
        hash = hash * 31 + (Int32)playerPostureType;
        hash = hash * 31 + (Int32)lastLocomotionType;
        hash = hash * 31 + (Int32)lastPostureType;
        hash = hash * 31 + lastVerticalSpeed.GetHashCode();
        hash = hash * 31 + enemyEntityRef.GetHashCode();
        hash = hash * 31 + currentHealthPoint.GetHashCode();
        hash = hash * 31 + currentToughPoint.GetHashCode();
        hash = hash * 31 + stunStatusEffect.GetHashCode();
        hash = hash * 31 + breakStatusEffect.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PlayerStatusComponent*)ptr;
        serializer.Stream.Serialize((Int32*)&p->lastLocomotionType);
        serializer.Stream.Serialize((Int32*)&p->playerLocomotionType);
        serializer.Stream.Serialize((Int32*)&p->lastPostureType);
        serializer.Stream.Serialize((Int32*)&p->playerPostureType);
        PlayerRef.Serialize(&p->playerRef, serializer);
        serializer.Stream.Serialize((Int32*)&p->PlayerTeam);
        EntityRef.Serialize(&p->SpawnerEntityRef, serializer);
        EntityRef.Serialize(&p->enemyEntityRef, serializer);
        FP.Serialize(&p->currentHealthPoint, serializer);
        FP.Serialize(&p->currentToughPoint, serializer);
        FP.Serialize(&p->lastVerticalSpeed, serializer);
        Quantum.CountdownTimer.Serialize(&p->damageBufferTimer, serializer);
        Quantum.CountdownTimer.Serialize(&p->jumpCoyoteTimer, serializer);
        Quantum.CountdownTimer.Serialize(&p->unbeatableTimer, serializer);
        Quantum.StunStatusEffect.Serialize(&p->stunStatusEffect, serializer);
        Quantum.BreakStatusEffect.Serialize(&p->breakStatusEffect, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PlayerTargetComponent : Quantum.IComponent {
    public const Int32 SIZE = 96;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(16)]
    [FramePrinter.FixedArrayAttribute(typeof(EntityRef), 10)]
    private fixed Byte _targetArray_[80];
    [FieldOffset(4)]
    public Int32 targetCount;
    [FieldOffset(8)]
    public EntityRef currentTarget;
    [FieldOffset(0)]
    public Int32 currentTargetIndex;
    public FixedArray<EntityRef> targetArray {
      get {
        fixed (byte* p = _targetArray_) { return new FixedArray<EntityRef>(p, 8, 10); }
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 18731;
        hash = hash * 31 + HashCodeUtils.GetArrayHashCode(targetArray);
        hash = hash * 31 + targetCount.GetHashCode();
        hash = hash * 31 + currentTarget.GetHashCode();
        hash = hash * 31 + currentTargetIndex.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PlayerTargetComponent*)ptr;
        serializer.Stream.Serialize(&p->currentTargetIndex);
        serializer.Stream.Serialize(&p->targetCount);
        EntityRef.Serialize(&p->currentTarget, serializer);
        FixedArray.Serialize(p->targetArray, serializer, Statics.SerializeEntityRef);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct ProjectileComponent : Quantum.IComponent {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(8)]
    public EntityRef Owner;
    [FieldOffset(0)]
    public AssetRef<PlayerPartsData_Gun> gunData;
    [FieldOffset(16)]
    public CountdownTimer projectileDurationTimer;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 12491;
        hash = hash * 31 + Owner.GetHashCode();
        hash = hash * 31 + gunData.GetHashCode();
        hash = hash * 31 + projectileDurationTimer.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (ProjectileComponent*)ptr;
        AssetRef.Serialize(&p->gunData, serializer);
        EntityRef.Serialize(&p->Owner, serializer);
        Quantum.CountdownTimer.Serialize(&p->projectileDurationTimer, serializer);
    }
  }
  public unsafe partial interface ISignalOnSpawnProjectileSignal : ISignal {
    void OnSpawnProjectileSignal(Frame f, EntityRef owner, PlayerPartsData_Gun gunData);
  }
  public unsafe partial interface ISignalOnCollisionProjectileHitCharacterSignal : ISignal {
    void OnCollisionProjectileHitCharacterSignal(Frame f, CollisionInfo3D info, ProjectileComponent* projectile, PlayerStatusComponent* playerStatusComponent);
  }
  public unsafe partial interface ISignalOnCollisionProjectileHitStaticObjectSignal : ISignal {
    void OnCollisionProjectileHitStaticObjectSignal(Frame f, CollisionInfo3D info, ProjectileComponent* projectile);
  }
  public unsafe partial interface ISignalOnCollisionCharacterHitNormalStaticObjectSignal : ISignal {
    void OnCollisionCharacterHitNormalStaticObjectSignal(Frame f, CollisionInfo3D info, PlayerStatusComponent* playerStatusComponent);
  }
  public unsafe partial interface ISignalOnPlayerDiedSignal : ISignal {
    void OnPlayerDiedSignal(Frame f, EntityRef playerEntityRef, PlayerTeam playerTeam);
  }
  public static unsafe partial class Constants {
  }
  public unsafe partial class Frame {
    private ISignalOnSpawnProjectileSignal[] _ISignalOnSpawnProjectileSignalSystems;
    private ISignalOnCollisionProjectileHitCharacterSignal[] _ISignalOnCollisionProjectileHitCharacterSignalSystems;
    private ISignalOnCollisionProjectileHitStaticObjectSignal[] _ISignalOnCollisionProjectileHitStaticObjectSignalSystems;
    private ISignalOnCollisionCharacterHitNormalStaticObjectSignal[] _ISignalOnCollisionCharacterHitNormalStaticObjectSignalSystems;
    private ISignalOnPlayerDiedSignal[] _ISignalOnPlayerDiedSignalSystems;
    partial void AllocGen() {
      _globals = (_globals_*)Context.Allocator.AllocAndClear(sizeof(_globals_));
    }
    partial void FreeGen() {
      Context.Allocator.Free(_globals);
    }
    partial void CopyFromGen(Frame frame) {
      Native.Utils.Copy(_globals, frame._globals, sizeof(_globals_));
    }
    partial void InitGen() {
      Initialize(this, this.SimulationConfig.Entities, 256);
      _ISignalOnSpawnProjectileSignalSystems = BuildSignalsArray<ISignalOnSpawnProjectileSignal>();
      _ISignalOnCollisionProjectileHitCharacterSignalSystems = BuildSignalsArray<ISignalOnCollisionProjectileHitCharacterSignal>();
      _ISignalOnCollisionProjectileHitStaticObjectSignalSystems = BuildSignalsArray<ISignalOnCollisionProjectileHitStaticObjectSignal>();
      _ISignalOnCollisionCharacterHitNormalStaticObjectSignalSystems = BuildSignalsArray<ISignalOnCollisionCharacterHitNormalStaticObjectSignal>();
      _ISignalOnPlayerDiedSignalSystems = BuildSignalsArray<ISignalOnPlayerDiedSignal>();
      _ComponentSignalsOnAdded = new ComponentReactiveCallbackInvoker[ComponentTypeId.Type.Length];
      _ComponentSignalsOnRemoved = new ComponentReactiveCallbackInvoker[ComponentTypeId.Type.Length];
      BuildSignalsArrayOnComponentAdded<CharacterController2D>();
      BuildSignalsArrayOnComponentRemoved<CharacterController2D>();
      BuildSignalsArrayOnComponentAdded<CharacterController3D>();
      BuildSignalsArrayOnComponentRemoved<CharacterController3D>();
      BuildSignalsArrayOnComponentAdded<Quantum.EnemyFlagComponent>();
      BuildSignalsArrayOnComponentRemoved<Quantum.EnemyFlagComponent>();
      BuildSignalsArrayOnComponentAdded<MapEntityLink>();
      BuildSignalsArrayOnComponentRemoved<MapEntityLink>();
      BuildSignalsArrayOnComponentAdded<NavMeshAvoidanceAgent>();
      BuildSignalsArrayOnComponentRemoved<NavMeshAvoidanceAgent>();
      BuildSignalsArrayOnComponentAdded<NavMeshAvoidanceObstacle>();
      BuildSignalsArrayOnComponentRemoved<NavMeshAvoidanceObstacle>();
      BuildSignalsArrayOnComponentAdded<NavMeshPathfinder>();
      BuildSignalsArrayOnComponentRemoved<NavMeshPathfinder>();
      BuildSignalsArrayOnComponentAdded<NavMeshSteeringAgent>();
      BuildSignalsArrayOnComponentRemoved<NavMeshSteeringAgent>();
      BuildSignalsArrayOnComponentAdded<PhysicsBody2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsBody2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsBody3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsBody3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCallbacks2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCallbacks2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCallbacks3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCallbacks3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCollider2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCollider2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCollider3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCollider3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsJoints2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsJoints2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsJoints3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsJoints3D>();
      BuildSignalsArrayOnComponentAdded<Quantum.PlayerActionComponent>();
      BuildSignalsArrayOnComponentRemoved<Quantum.PlayerActionComponent>();
      BuildSignalsArrayOnComponentAdded<Quantum.PlayerDatabaseComponent>();
      BuildSignalsArrayOnComponentRemoved<Quantum.PlayerDatabaseComponent>();
      BuildSignalsArrayOnComponentAdded<Quantum.PlayerMovementComponent>();
      BuildSignalsArrayOnComponentRemoved<Quantum.PlayerMovementComponent>();
      BuildSignalsArrayOnComponentAdded<Quantum.PlayerSpawnerComponent>();
      BuildSignalsArrayOnComponentRemoved<Quantum.PlayerSpawnerComponent>();
      BuildSignalsArrayOnComponentAdded<Quantum.PlayerStatusComponent>();
      BuildSignalsArrayOnComponentRemoved<Quantum.PlayerStatusComponent>();
      BuildSignalsArrayOnComponentAdded<Quantum.PlayerTargetComponent>();
      BuildSignalsArrayOnComponentRemoved<Quantum.PlayerTargetComponent>();
      BuildSignalsArrayOnComponentAdded<Quantum.ProjectileComponent>();
      BuildSignalsArrayOnComponentRemoved<Quantum.ProjectileComponent>();
      BuildSignalsArrayOnComponentAdded<Transform2D>();
      BuildSignalsArrayOnComponentRemoved<Transform2D>();
      BuildSignalsArrayOnComponentAdded<Transform2DVertical>();
      BuildSignalsArrayOnComponentRemoved<Transform2DVertical>();
      BuildSignalsArrayOnComponentAdded<Transform3D>();
      BuildSignalsArrayOnComponentRemoved<Transform3D>();
      BuildSignalsArrayOnComponentAdded<View>();
      BuildSignalsArrayOnComponentRemoved<View>();
    }
    partial void SetPlayerInputCodeGen(PlayerRef player, Input input) {
      if ((int)player >= (int)_globals->input.Length) { throw new System.ArgumentOutOfRangeException("player"); }
      var i = _globals->input.GetPointer(player);
      i->Jump = i->Jump.Update(this.Number, input.Jump);
      i->Dash = i->Dash.Update(this.Number, input.Dash);
      i->Gun = i->Gun.Update(this.Number, input.Gun);
      i->SwitchTarget = i->SwitchTarget.Update(this.Number, input.SwitchTarget);
      i->PlayerMovementDirection = input.PlayerMovementDirection;
      i->CameraMovementDirection = input.CameraMovementDirection;
      i->MovementEncoded = input.MovementEncoded;
    }
    public Input* GetPlayerInput(PlayerRef player) {
      if ((int)player >= (int)_globals->input.Length) { throw new System.ArgumentOutOfRangeException("player"); }
      return _globals->input.GetPointer(player);
    }
    partial void GetPlayerLastConnectionStateCodeGen(ref BitSetRef bitSet) {
      bitSet = new(_globals->PlayerLastConnectionState.Bits, _globals->PlayerLastConnectionState.Length);
    }
    partial void ResetPhysicsCodeGen() {
      if (Context.Physics2D != null && Physics2D.Map != null && Physics2D.Map.Guid.IsDynamic) Physics2D.ResetMap();
      Physics2D.Init(_globals->PhysicsState2D.MapStaticCollidersState.TrackedMap);
      if (Context.Physics3D != null && Physics3D.Map != null && Physics3D.Map.Guid.IsDynamic) Physics3D.ResetMap();
      Physics3D.Init(_globals->PhysicsState3D.MapStaticCollidersState.TrackedMap);
    }
    public unsafe partial struct FrameSignals {
      public void OnSpawnProjectileSignal(EntityRef owner, PlayerPartsData_Gun gunData) {
        var array = _f._ISignalOnSpawnProjectileSignalSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnSpawnProjectileSignal(_f, owner, gunData);
          }
        }
      }
      public void OnCollisionProjectileHitCharacterSignal(CollisionInfo3D info, ProjectileComponent* projectile, PlayerStatusComponent* playerStatusComponent) {
        var array = _f._ISignalOnCollisionProjectileHitCharacterSignalSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnCollisionProjectileHitCharacterSignal(_f, info, projectile, playerStatusComponent);
          }
        }
      }
      public void OnCollisionProjectileHitStaticObjectSignal(CollisionInfo3D info, ProjectileComponent* projectile) {
        var array = _f._ISignalOnCollisionProjectileHitStaticObjectSignalSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnCollisionProjectileHitStaticObjectSignal(_f, info, projectile);
          }
        }
      }
      public void OnCollisionCharacterHitNormalStaticObjectSignal(CollisionInfo3D info, PlayerStatusComponent* playerStatusComponent) {
        var array = _f._ISignalOnCollisionCharacterHitNormalStaticObjectSignalSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnCollisionCharacterHitNormalStaticObjectSignal(_f, info, playerStatusComponent);
          }
        }
      }
      public void OnPlayerDiedSignal(EntityRef playerEntityRef, PlayerTeam playerTeam) {
        var array = _f._ISignalOnPlayerDiedSignalSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnPlayerDiedSignal(_f, playerEntityRef, playerTeam);
          }
        }
      }
    }
  }
  public unsafe partial class Statics {
    public static FrameSerializer.Delegate SerializePlayerActionInfo;
    public static FrameSerializer.Delegate SerializeFP;
    public static FrameSerializer.Delegate SerializeFPVector3;
    public static FrameSerializer.Delegate SerializeEntityRef;
    public static FrameSerializer.Delegate SerializeInput;
    static partial void InitStaticDelegatesGen() {
      SerializePlayerActionInfo = Quantum.PlayerActionInfo.Serialize;
      SerializeFP = FP.Serialize;
      SerializeFPVector3 = FPVector3.Serialize;
      SerializeEntityRef = EntityRef.Serialize;
      SerializeInput = Quantum.Input.Serialize;
    }
    static partial void RegisterSimulationTypesGen(TypeRegistry typeRegistry) {
      typeRegistry.Register(typeof(Quantum.ActionAvailabilityCondition), 4);
      typeRegistry.Register(typeof(Quantum.ActionType), 4);
      typeRegistry.Register(typeof(Quantum.ActionsParameter), Quantum.ActionsParameter.SIZE);
      typeRegistry.Register(typeof(Quantum.ActiveActionInfo), Quantum.ActiveActionInfo.SIZE);
      typeRegistry.Register(typeof(AssetGuid), AssetGuid.SIZE);
      typeRegistry.Register(typeof(AssetRef), AssetRef.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet1024), Quantum.BitSet1024.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet128), Quantum.BitSet128.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet2048), Quantum.BitSet2048.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet256), Quantum.BitSet256.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet4096), Quantum.BitSet4096.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet512), Quantum.BitSet512.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet6), Quantum.BitSet6.SIZE);
      typeRegistry.Register(typeof(Quantum.BodyDatabase), Quantum.BodyDatabase.SIZE);
      typeRegistry.Register(typeof(Quantum.BreakStatusEffect), Quantum.BreakStatusEffect.SIZE);
      typeRegistry.Register(typeof(Button), Button.SIZE);
      typeRegistry.Register(typeof(CallbackFlags), 4);
      typeRegistry.Register(typeof(CharacterController2D), CharacterController2D.SIZE);
      typeRegistry.Register(typeof(CharacterController3D), CharacterController3D.SIZE);
      typeRegistry.Register(typeof(Quantum.CinematicCameraType), 4);
      typeRegistry.Register(typeof(ColorRGBA), ColorRGBA.SIZE);
      typeRegistry.Register(typeof(ComponentPrototypeRef), ComponentPrototypeRef.SIZE);
      typeRegistry.Register(typeof(ComponentTypeRef), ComponentTypeRef.SIZE);
      typeRegistry.Register(typeof(Quantum.CountdownTimer), Quantum.CountdownTimer.SIZE);
      typeRegistry.Register(typeof(Quantum.DashAction), Quantum.DashAction.SIZE);
      typeRegistry.Register(typeof(DistanceJoint), DistanceJoint.SIZE);
      typeRegistry.Register(typeof(DistanceJoint3D), DistanceJoint3D.SIZE);
      typeRegistry.Register(typeof(Quantum.EnemyFlagComponent), Quantum.EnemyFlagComponent.SIZE);
      typeRegistry.Register(typeof(EntityPrototypeRef), EntityPrototypeRef.SIZE);
      typeRegistry.Register(typeof(EntityRef), EntityRef.SIZE);
      typeRegistry.Register(typeof(Quantum.EntityType), 4);
      typeRegistry.Register(typeof(FP), FP.SIZE);
      typeRegistry.Register(typeof(FPBounds2), FPBounds2.SIZE);
      typeRegistry.Register(typeof(FPBounds3), FPBounds3.SIZE);
      typeRegistry.Register(typeof(FPMatrix2x2), FPMatrix2x2.SIZE);
      typeRegistry.Register(typeof(FPMatrix3x3), FPMatrix3x3.SIZE);
      typeRegistry.Register(typeof(FPMatrix4x4), FPMatrix4x4.SIZE);
      typeRegistry.Register(typeof(FPQuaternion), FPQuaternion.SIZE);
      typeRegistry.Register(typeof(FPVector2), FPVector2.SIZE);
      typeRegistry.Register(typeof(FPVector3), FPVector3.SIZE);
      typeRegistry.Register(typeof(FrameMetaData), FrameMetaData.SIZE);
      typeRegistry.Register(typeof(FrameTimer), FrameTimer.SIZE);
      typeRegistry.Register(typeof(Quantum.GameState), 4);
      typeRegistry.Register(typeof(Quantum.GunAction), Quantum.GunAction.SIZE);
      typeRegistry.Register(typeof(Quantum.GunDatabase), Quantum.GunDatabase.SIZE);
      typeRegistry.Register(typeof(HingeJoint), HingeJoint.SIZE);
      typeRegistry.Register(typeof(HingeJoint3D), HingeJoint3D.SIZE);
      typeRegistry.Register(typeof(Hit), Hit.SIZE);
      typeRegistry.Register(typeof(Hit3D), Hit3D.SIZE);
      typeRegistry.Register(typeof(Quantum.Input), Quantum.Input.SIZE);
      typeRegistry.Register(typeof(Quantum.InputButtons), 4);
      typeRegistry.Register(typeof(IntVector2), IntVector2.SIZE);
      typeRegistry.Register(typeof(IntVector3), IntVector3.SIZE);
      typeRegistry.Register(typeof(Joint), Joint.SIZE);
      typeRegistry.Register(typeof(Joint3D), Joint3D.SIZE);
      typeRegistry.Register(typeof(Quantum.JumpAction), Quantum.JumpAction.SIZE);
      typeRegistry.Register(typeof(LayerMask), LayerMask.SIZE);
      typeRegistry.Register(typeof(MapEntityId), MapEntityId.SIZE);
      typeRegistry.Register(typeof(MapEntityLink), MapEntityLink.SIZE);
      typeRegistry.Register(typeof(NavMeshAvoidanceAgent), NavMeshAvoidanceAgent.SIZE);
      typeRegistry.Register(typeof(NavMeshAvoidanceObstacle), NavMeshAvoidanceObstacle.SIZE);
      typeRegistry.Register(typeof(NavMeshPathfinder), NavMeshPathfinder.SIZE);
      typeRegistry.Register(typeof(NavMeshRegionMask), NavMeshRegionMask.SIZE);
      typeRegistry.Register(typeof(NavMeshSteeringAgent), NavMeshSteeringAgent.SIZE);
      typeRegistry.Register(typeof(NullableFP), NullableFP.SIZE);
      typeRegistry.Register(typeof(NullableFPVector2), NullableFPVector2.SIZE);
      typeRegistry.Register(typeof(NullableFPVector3), NullableFPVector3.SIZE);
      typeRegistry.Register(typeof(NullableNonNegativeFP), NullableNonNegativeFP.SIZE);
      typeRegistry.Register(typeof(PhysicsBody2D), PhysicsBody2D.SIZE);
      typeRegistry.Register(typeof(PhysicsBody3D), PhysicsBody3D.SIZE);
      typeRegistry.Register(typeof(PhysicsCallbacks2D), PhysicsCallbacks2D.SIZE);
      typeRegistry.Register(typeof(PhysicsCallbacks3D), PhysicsCallbacks3D.SIZE);
      typeRegistry.Register(typeof(PhysicsCollider2D), PhysicsCollider2D.SIZE);
      typeRegistry.Register(typeof(PhysicsCollider3D), PhysicsCollider3D.SIZE);
      typeRegistry.Register(typeof(PhysicsEngineState), PhysicsEngineState.SIZE);
      typeRegistry.Register(typeof(PhysicsJoints2D), PhysicsJoints2D.SIZE);
      typeRegistry.Register(typeof(PhysicsJoints3D), PhysicsJoints3D.SIZE);
      typeRegistry.Register(typeof(PhysicsQueryRef), PhysicsQueryRef.SIZE);
      typeRegistry.Register(typeof(PhysicsSceneSettings), PhysicsSceneSettings.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayerActionComponent), Quantum.PlayerActionComponent.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayerActionInfo), Quantum.PlayerActionInfo.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayerDatabaseComponent), Quantum.PlayerDatabaseComponent.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayerLocomotionType), 4);
      typeRegistry.Register(typeof(Quantum.PlayerMovementComponent), Quantum.PlayerMovementComponent.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayerPartsType), 4);
      typeRegistry.Register(typeof(Quantum.PlayerPostureType), 4);
      typeRegistry.Register(typeof(PlayerRef), PlayerRef.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayerSpawnerComponent), Quantum.PlayerSpawnerComponent.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayerStatusComponent), Quantum.PlayerStatusComponent.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayerTargetComponent), Quantum.PlayerTargetComponent.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayerTeam), 4);
      typeRegistry.Register(typeof(Quantum.PlayerWeaponStateType), 4);
      typeRegistry.Register(typeof(Quantum.ProjectileComponent), Quantum.ProjectileComponent.SIZE);
      typeRegistry.Register(typeof(Ptr), Ptr.SIZE);
      typeRegistry.Register(typeof(QBoolean), QBoolean.SIZE);
      typeRegistry.Register(typeof(Quantum.Ptr), Quantum.Ptr.SIZE);
      typeRegistry.Register(typeof(QueryOptions), 2);
      typeRegistry.Register(typeof(RNGSession), RNGSession.SIZE);
      typeRegistry.Register(typeof(Shape2D), Shape2D.SIZE);
      typeRegistry.Register(typeof(Shape3D), Shape3D.SIZE);
      typeRegistry.Register(typeof(SpringJoint), SpringJoint.SIZE);
      typeRegistry.Register(typeof(SpringJoint3D), SpringJoint3D.SIZE);
      typeRegistry.Register(typeof(Quantum.StunStatusEffect), Quantum.StunStatusEffect.SIZE);
      typeRegistry.Register(typeof(Transform2D), Transform2D.SIZE);
      typeRegistry.Register(typeof(Transform2DVertical), Transform2DVertical.SIZE);
      typeRegistry.Register(typeof(Transform3D), Transform3D.SIZE);
      typeRegistry.Register(typeof(View), View.SIZE);
      typeRegistry.Register(typeof(Quantum._globals_), Quantum._globals_.SIZE);
    }
    static partial void InitComponentTypeIdGen() {
      ComponentTypeId.Reset(ComponentTypeId.BuiltInComponentCount + 8)
        .AddBuiltInComponents()
        .Add<Quantum.EnemyFlagComponent>(Quantum.EnemyFlagComponent.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.PlayerActionComponent>(Quantum.PlayerActionComponent.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.PlayerDatabaseComponent>(Quantum.PlayerDatabaseComponent.Serialize, null, Quantum.PlayerDatabaseComponent.OnRemoved, ComponentFlags.None)
        .Add<Quantum.PlayerMovementComponent>(Quantum.PlayerMovementComponent.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.PlayerSpawnerComponent>(Quantum.PlayerSpawnerComponent.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.PlayerStatusComponent>(Quantum.PlayerStatusComponent.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.PlayerTargetComponent>(Quantum.PlayerTargetComponent.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.ProjectileComponent>(Quantum.ProjectileComponent.Serialize, null, null, ComponentFlags.None)
        .Finish();
    }
    [Preserve()]
    public static void EnsureNotStrippedGen() {
      FramePrinter.EnsureNotStripped();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.ActionAvailabilityCondition>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.ActionType>();
      FramePrinter.EnsurePrimitiveNotStripped<CallbackFlags>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.CinematicCameraType>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.EntityType>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.GameState>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.InputButtons>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.PlayerLocomotionType>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.PlayerPartsType>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.PlayerPostureType>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.PlayerTeam>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.PlayerWeaponStateType>();
      FramePrinter.EnsurePrimitiveNotStripped<QueryOptions>();
    }
  }
}
#pragma warning restore 0109
#pragma warning restore 1591
